/*
 * Taurus-PROTECT APIs
 * Taurus-PROTECT APIs description
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.taurushq.sdk.protect.openapi.api;

import com.taurushq.sdk.protect.openapi.ApiCallback;
import com.taurushq.sdk.protect.openapi.ApiClient;
import com.taurushq.sdk.protect.openapi.ApiException;
import com.taurushq.sdk.protect.openapi.ApiResponse;
import com.taurushq.sdk.protect.openapi.Configuration;
import com.taurushq.sdk.protect.openapi.Pair;
import com.taurushq.sdk.protect.openapi.ProgressRequestBody;
import com.taurushq.sdk.protect.openapi.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.taurushq.sdk.protect.openapi.model.GooglerpcStatus;
import com.taurushq.sdk.protect.openapi.model.TgvalidatordApproveWhitelistedAddressRequest;
import com.taurushq.sdk.protect.openapi.model.TgvalidatordApproveWhitelistingReply;
import com.taurushq.sdk.protect.openapi.model.TgvalidatordCreateReply;
import com.taurushq.sdk.protect.openapi.model.TgvalidatordCreateWhitelistedAddressAttributesReply;
import com.taurushq.sdk.protect.openapi.model.TgvalidatordCreateWhitelistedAddressRequest;
import com.taurushq.sdk.protect.openapi.model.TgvalidatordDeleteWhitelistedAddressRequest;
import com.taurushq.sdk.protect.openapi.model.TgvalidatordExportWhitelistedAddressesReply;
import com.taurushq.sdk.protect.openapi.model.TgvalidatordGetSignedWhitelistedAddressEnvelopeReply;
import com.taurushq.sdk.protect.openapi.model.TgvalidatordGetSignedWhitelistedAddressEnvelopesReply;
import com.taurushq.sdk.protect.openapi.model.TgvalidatordGetWhitelistedAddressAttributeReply;
import com.taurushq.sdk.protect.openapi.model.TgvalidatordRejectWhitelistedAddressRequest;
import com.taurushq.sdk.protect.openapi.model.WhitelistServiceCreateWhitelistedAddressAttributesBody;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class AddressWhitelistingApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public AddressWhitelistingApi() {
        this(Configuration.getDefaultApiClient());
    }

    public AddressWhitelistingApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for whitelistServiceApproveWhitelistedAddress
     * @param body  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceApproveWhitelistedAddressCall(TgvalidatordApproveWhitelistedAddressRequest body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/rest/v1/whitelists/addresses/approve";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyTPV1" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call whitelistServiceApproveWhitelistedAddressValidateBeforeCall(TgvalidatordApproveWhitelistedAddressRequest body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling whitelistServiceApproveWhitelistedAddress(Async)");
        }

        return whitelistServiceApproveWhitelistedAddressCall(body, _callback);

    }

    /**
     * Approve a whitelisted address
     * This endpoint approves a whitelisted address.  Required role: **WhitelistedAddressApprover**.
     * @param body  (required)
     * @return TgvalidatordApproveWhitelistingReply
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public TgvalidatordApproveWhitelistingReply whitelistServiceApproveWhitelistedAddress(TgvalidatordApproveWhitelistedAddressRequest body) throws ApiException {
        ApiResponse<TgvalidatordApproveWhitelistingReply> localVarResp = whitelistServiceApproveWhitelistedAddressWithHttpInfo(body);
        return localVarResp.getData();
    }

    /**
     * Approve a whitelisted address
     * This endpoint approves a whitelisted address.  Required role: **WhitelistedAddressApprover**.
     * @param body  (required)
     * @return ApiResponse&lt;TgvalidatordApproveWhitelistingReply&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TgvalidatordApproveWhitelistingReply> whitelistServiceApproveWhitelistedAddressWithHttpInfo(TgvalidatordApproveWhitelistedAddressRequest body) throws ApiException {
        okhttp3.Call localVarCall = whitelistServiceApproveWhitelistedAddressValidateBeforeCall(body, null);
        Type localVarReturnType = new TypeToken<TgvalidatordApproveWhitelistingReply>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Approve a whitelisted address (asynchronously)
     * This endpoint approves a whitelisted address.  Required role: **WhitelistedAddressApprover**.
     * @param body  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceApproveWhitelistedAddressAsync(TgvalidatordApproveWhitelistedAddressRequest body, final ApiCallback<TgvalidatordApproveWhitelistingReply> _callback) throws ApiException {

        okhttp3.Call localVarCall = whitelistServiceApproveWhitelistedAddressValidateBeforeCall(body, _callback);
        Type localVarReturnType = new TypeToken<TgvalidatordApproveWhitelistingReply>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for whitelistServiceCreateWhitelistedAddress
     * @param body  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceCreateWhitelistedAddressCall(TgvalidatordCreateWhitelistedAddressRequest body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/rest/v1/whitelists/addresses";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyTPV1" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call whitelistServiceCreateWhitelistedAddressValidateBeforeCall(TgvalidatordCreateWhitelistedAddressRequest body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling whitelistServiceCreateWhitelistedAddress(Async)");
        }

        return whitelistServiceCreateWhitelistedAddressCall(body, _callback);

    }

    /**
     * Create a whitelisted address
     * This endpoint creates a new whitelisted address.  Required role: **WhitelistedAddressCreator**.
     * @param body  (required)
     * @return TgvalidatordCreateReply
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public TgvalidatordCreateReply whitelistServiceCreateWhitelistedAddress(TgvalidatordCreateWhitelistedAddressRequest body) throws ApiException {
        ApiResponse<TgvalidatordCreateReply> localVarResp = whitelistServiceCreateWhitelistedAddressWithHttpInfo(body);
        return localVarResp.getData();
    }

    /**
     * Create a whitelisted address
     * This endpoint creates a new whitelisted address.  Required role: **WhitelistedAddressCreator**.
     * @param body  (required)
     * @return ApiResponse&lt;TgvalidatordCreateReply&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TgvalidatordCreateReply> whitelistServiceCreateWhitelistedAddressWithHttpInfo(TgvalidatordCreateWhitelistedAddressRequest body) throws ApiException {
        okhttp3.Call localVarCall = whitelistServiceCreateWhitelistedAddressValidateBeforeCall(body, null);
        Type localVarReturnType = new TypeToken<TgvalidatordCreateReply>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a whitelisted address (asynchronously)
     * This endpoint creates a new whitelisted address.  Required role: **WhitelistedAddressCreator**.
     * @param body  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceCreateWhitelistedAddressAsync(TgvalidatordCreateWhitelistedAddressRequest body, final ApiCallback<TgvalidatordCreateReply> _callback) throws ApiException {

        okhttp3.Call localVarCall = whitelistServiceCreateWhitelistedAddressValidateBeforeCall(body, _callback);
        Type localVarReturnType = new TypeToken<TgvalidatordCreateReply>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for whitelistServiceCreateWhitelistedAddressAttributes
     * @param whitelistedAddressId  (required)
     * @param body  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceCreateWhitelistedAddressAttributesCall(String whitelistedAddressId, WhitelistServiceCreateWhitelistedAddressAttributesBody body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/rest/v1/whitelists/addresses/{whitelistedAddressId}/attributes"
            .replace("{" + "whitelistedAddressId" + "}", localVarApiClient.escapeString(whitelistedAddressId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyTPV1" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call whitelistServiceCreateWhitelistedAddressAttributesValidateBeforeCall(String whitelistedAddressId, WhitelistServiceCreateWhitelistedAddressAttributesBody body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'whitelistedAddressId' is set
        if (whitelistedAddressId == null) {
            throw new ApiException("Missing the required parameter 'whitelistedAddressId' when calling whitelistServiceCreateWhitelistedAddressAttributes(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling whitelistServiceCreateWhitelistedAddressAttributes(Async)");
        }

        return whitelistServiceCreateWhitelistedAddressAttributesCall(whitelistedAddressId, body, _callback);

    }

    /**
     * Create attributes
     * This endpoint creates attributes of a given whitelisted address.  Required role: **WhitelistedAddressCreator**.
     * @param whitelistedAddressId  (required)
     * @param body  (required)
     * @return TgvalidatordCreateWhitelistedAddressAttributesReply
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public TgvalidatordCreateWhitelistedAddressAttributesReply whitelistServiceCreateWhitelistedAddressAttributes(String whitelistedAddressId, WhitelistServiceCreateWhitelistedAddressAttributesBody body) throws ApiException {
        ApiResponse<TgvalidatordCreateWhitelistedAddressAttributesReply> localVarResp = whitelistServiceCreateWhitelistedAddressAttributesWithHttpInfo(whitelistedAddressId, body);
        return localVarResp.getData();
    }

    /**
     * Create attributes
     * This endpoint creates attributes of a given whitelisted address.  Required role: **WhitelistedAddressCreator**.
     * @param whitelistedAddressId  (required)
     * @param body  (required)
     * @return ApiResponse&lt;TgvalidatordCreateWhitelistedAddressAttributesReply&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TgvalidatordCreateWhitelistedAddressAttributesReply> whitelistServiceCreateWhitelistedAddressAttributesWithHttpInfo(String whitelistedAddressId, WhitelistServiceCreateWhitelistedAddressAttributesBody body) throws ApiException {
        okhttp3.Call localVarCall = whitelistServiceCreateWhitelistedAddressAttributesValidateBeforeCall(whitelistedAddressId, body, null);
        Type localVarReturnType = new TypeToken<TgvalidatordCreateWhitelistedAddressAttributesReply>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create attributes (asynchronously)
     * This endpoint creates attributes of a given whitelisted address.  Required role: **WhitelistedAddressCreator**.
     * @param whitelistedAddressId  (required)
     * @param body  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceCreateWhitelistedAddressAttributesAsync(String whitelistedAddressId, WhitelistServiceCreateWhitelistedAddressAttributesBody body, final ApiCallback<TgvalidatordCreateWhitelistedAddressAttributesReply> _callback) throws ApiException {

        okhttp3.Call localVarCall = whitelistServiceCreateWhitelistedAddressAttributesValidateBeforeCall(whitelistedAddressId, body, _callback);
        Type localVarReturnType = new TypeToken<TgvalidatordCreateWhitelistedAddressAttributesReply>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for whitelistServiceDeleteWhitelistedAddress
     * @param body  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceDeleteWhitelistedAddressCall(TgvalidatordDeleteWhitelistedAddressRequest body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/rest/v1/whitelists/addresses/delete";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyTPV1" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call whitelistServiceDeleteWhitelistedAddressValidateBeforeCall(TgvalidatordDeleteWhitelistedAddressRequest body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling whitelistServiceDeleteWhitelistedAddress(Async)");
        }

        return whitelistServiceDeleteWhitelistedAddressCall(body, _callback);

    }

    /**
     * Delete a whitelisted address
     * This endpoint deletes a whitelisted address.  Required role: **WhitelistedAddressCreator**.
     * @param body  (required)
     * @return TgvalidatordCreateReply
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public TgvalidatordCreateReply whitelistServiceDeleteWhitelistedAddress(TgvalidatordDeleteWhitelistedAddressRequest body) throws ApiException {
        ApiResponse<TgvalidatordCreateReply> localVarResp = whitelistServiceDeleteWhitelistedAddressWithHttpInfo(body);
        return localVarResp.getData();
    }

    /**
     * Delete a whitelisted address
     * This endpoint deletes a whitelisted address.  Required role: **WhitelistedAddressCreator**.
     * @param body  (required)
     * @return ApiResponse&lt;TgvalidatordCreateReply&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TgvalidatordCreateReply> whitelistServiceDeleteWhitelistedAddressWithHttpInfo(TgvalidatordDeleteWhitelistedAddressRequest body) throws ApiException {
        okhttp3.Call localVarCall = whitelistServiceDeleteWhitelistedAddressValidateBeforeCall(body, null);
        Type localVarReturnType = new TypeToken<TgvalidatordCreateReply>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete a whitelisted address (asynchronously)
     * This endpoint deletes a whitelisted address.  Required role: **WhitelistedAddressCreator**.
     * @param body  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceDeleteWhitelistedAddressAsync(TgvalidatordDeleteWhitelistedAddressRequest body, final ApiCallback<TgvalidatordCreateReply> _callback) throws ApiException {

        okhttp3.Call localVarCall = whitelistServiceDeleteWhitelistedAddressValidateBeforeCall(body, _callback);
        Type localVarReturnType = new TypeToken<TgvalidatordCreateReply>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for whitelistServiceDeleteWhitelistedAddressAttribute
     * @param whitelistedAddressId  (required)
     * @param id  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceDeleteWhitelistedAddressAttributeCall(String whitelistedAddressId, String id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/rest/v1/whitelists/addresses/{whitelistedAddressId}/attributes/{id}"
            .replace("{" + "whitelistedAddressId" + "}", localVarApiClient.escapeString(whitelistedAddressId.toString()))
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyTPV1" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call whitelistServiceDeleteWhitelistedAddressAttributeValidateBeforeCall(String whitelistedAddressId, String id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'whitelistedAddressId' is set
        if (whitelistedAddressId == null) {
            throw new ApiException("Missing the required parameter 'whitelistedAddressId' when calling whitelistServiceDeleteWhitelistedAddressAttribute(Async)");
        }

        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling whitelistServiceDeleteWhitelistedAddressAttribute(Async)");
        }

        return whitelistServiceDeleteWhitelistedAddressAttributeCall(whitelistedAddressId, id, _callback);

    }

    /**
     * Delete an attribute
     * This endpoint deletes an attribute of a given whitelisted address.  Required role: **WhitelistedAddressCreator**.
     * @param whitelistedAddressId  (required)
     * @param id  (required)
     * @return Object
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public Object whitelistServiceDeleteWhitelistedAddressAttribute(String whitelistedAddressId, String id) throws ApiException {
        ApiResponse<Object> localVarResp = whitelistServiceDeleteWhitelistedAddressAttributeWithHttpInfo(whitelistedAddressId, id);
        return localVarResp.getData();
    }

    /**
     * Delete an attribute
     * This endpoint deletes an attribute of a given whitelisted address.  Required role: **WhitelistedAddressCreator**.
     * @param whitelistedAddressId  (required)
     * @param id  (required)
     * @return ApiResponse&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Object> whitelistServiceDeleteWhitelistedAddressAttributeWithHttpInfo(String whitelistedAddressId, String id) throws ApiException {
        okhttp3.Call localVarCall = whitelistServiceDeleteWhitelistedAddressAttributeValidateBeforeCall(whitelistedAddressId, id, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete an attribute (asynchronously)
     * This endpoint deletes an attribute of a given whitelisted address.  Required role: **WhitelistedAddressCreator**.
     * @param whitelistedAddressId  (required)
     * @param id  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceDeleteWhitelistedAddressAttributeAsync(String whitelistedAddressId, String id, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = whitelistServiceDeleteWhitelistedAddressAttributeValidateBeforeCall(whitelistedAddressId, id, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for whitelistServiceExportWhitelistedAddresses
     * @param format  (optional)
     * @param exchangeAccountId Use exchangeAccountIds instead (optional)
     * @param addressType  (optional)
     * @param query  (optional)
     * @param currency Use blockchain instead (optional)
     * @param scoreProvider Deprecated. Use scoreFilter instead. (optional)
     * @param scoreInBelow Deprecated. Use scoreFilter instead. (optional)
     * @param scoreOutBelow Deprecated. Use scoreFilter instead. (optional)
     * @param scoreExclusive Deprecated. Use scoreFilter instead. (optional)
     * @param exchangeAccountIds  (optional)
     * @param coinfirmScoreGreater Deprecated. Use scoreFilter instead. (optional)
     * @param tags  (optional)
     * @param chainalysisScoreGreater Deprecated. Use scoreFilter instead. (optional)
     * @param blockchain Filter on the blockchain of the WLA (optional)
     * @param addresses Filter on the specific WLAs to export (optional)
     * @param network  (optional)
     * @param scoreFilterScoreProvider Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: &#39;scorechain&#39;, &#39;coinfirm&#39;, &#39;chainalysis&#39;, &#39;elliptic&#39; (optional)
     * @param scoreFilterScorechainFiltersScoreInBelow Filter addresses under a Scorechain incoming score threshold. (optional)
     * @param scoreFilterScorechainFiltersScoreOutBelow Filter addresses under a Scorechain outgoing score threshold. (optional)
     * @param scoreFilterScorechainFiltersScoreExclusive By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow). (optional)
     * @param scoreFilterCoinfirmFiltersScoreGreater Filter addresses with a Coinfirm C-score above threshold. (optional)
     * @param scoreFilterChainalysisFiltersScoreGreater Filter addresses with a Chainalysis risk score above threshold. (optional)
     * @param scoreFilterEllipticFiltersScoreGreater Filter addresses with an Elliptic risk score above threshold. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceExportWhitelistedAddressesCall(String format, String exchangeAccountId, String addressType, String query, String currency, String scoreProvider, String scoreInBelow, String scoreOutBelow, Boolean scoreExclusive, List<String> exchangeAccountIds, String coinfirmScoreGreater, List<String> tags, String chainalysisScoreGreater, String blockchain, List<String> addresses, String network, String scoreFilterScoreProvider, String scoreFilterScorechainFiltersScoreInBelow, String scoreFilterScorechainFiltersScoreOutBelow, Boolean scoreFilterScorechainFiltersScoreExclusive, String scoreFilterCoinfirmFiltersScoreGreater, String scoreFilterChainalysisFiltersScoreGreater, String scoreFilterEllipticFiltersScoreGreater, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/rest/v1/whitelists/addresses/export";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        if (exchangeAccountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("exchangeAccountId", exchangeAccountId));
        }

        if (addressType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("addressType", addressType));
        }

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        if (currency != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency", currency));
        }

        if (scoreProvider != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreProvider", scoreProvider));
        }

        if (scoreInBelow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreInBelow", scoreInBelow));
        }

        if (scoreOutBelow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreOutBelow", scoreOutBelow));
        }

        if (scoreExclusive != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreExclusive", scoreExclusive));
        }

        if (exchangeAccountIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "exchangeAccountIds", exchangeAccountIds));
        }

        if (coinfirmScoreGreater != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("coinfirmScoreGreater", coinfirmScoreGreater));
        }

        if (tags != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "tags", tags));
        }

        if (chainalysisScoreGreater != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("chainalysisScoreGreater", chainalysisScoreGreater));
        }

        if (blockchain != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("blockchain", blockchain));
        }

        if (addresses != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "addresses", addresses));
        }

        if (network != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("network", network));
        }

        if (scoreFilterScoreProvider != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreFilter.scoreProvider", scoreFilterScoreProvider));
        }

        if (scoreFilterScorechainFiltersScoreInBelow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreFilter.scorechainFilters.scoreInBelow", scoreFilterScorechainFiltersScoreInBelow));
        }

        if (scoreFilterScorechainFiltersScoreOutBelow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreFilter.scorechainFilters.scoreOutBelow", scoreFilterScorechainFiltersScoreOutBelow));
        }

        if (scoreFilterScorechainFiltersScoreExclusive != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreFilter.scorechainFilters.scoreExclusive", scoreFilterScorechainFiltersScoreExclusive));
        }

        if (scoreFilterCoinfirmFiltersScoreGreater != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreFilter.coinfirmFilters.scoreGreater", scoreFilterCoinfirmFiltersScoreGreater));
        }

        if (scoreFilterChainalysisFiltersScoreGreater != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreFilter.chainalysisFilters.scoreGreater", scoreFilterChainalysisFiltersScoreGreater));
        }

        if (scoreFilterEllipticFiltersScoreGreater != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreFilter.ellipticFilters.scoreGreater", scoreFilterEllipticFiltersScoreGreater));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyTPV1" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call whitelistServiceExportWhitelistedAddressesValidateBeforeCall(String format, String exchangeAccountId, String addressType, String query, String currency, String scoreProvider, String scoreInBelow, String scoreOutBelow, Boolean scoreExclusive, List<String> exchangeAccountIds, String coinfirmScoreGreater, List<String> tags, String chainalysisScoreGreater, String blockchain, List<String> addresses, String network, String scoreFilterScoreProvider, String scoreFilterScorechainFiltersScoreInBelow, String scoreFilterScorechainFiltersScoreOutBelow, Boolean scoreFilterScorechainFiltersScoreExclusive, String scoreFilterCoinfirmFiltersScoreGreater, String scoreFilterChainalysisFiltersScoreGreater, String scoreFilterEllipticFiltersScoreGreater, final ApiCallback _callback) throws ApiException {
        return whitelistServiceExportWhitelistedAddressesCall(format, exchangeAccountId, addressType, query, currency, scoreProvider, scoreInBelow, scoreOutBelow, scoreExclusive, exchangeAccountIds, coinfirmScoreGreater, tags, chainalysisScoreGreater, blockchain, addresses, network, scoreFilterScoreProvider, scoreFilterScorechainFiltersScoreInBelow, scoreFilterScorechainFiltersScoreOutBelow, scoreFilterScorechainFiltersScoreExclusive, scoreFilterCoinfirmFiltersScoreGreater, scoreFilterChainalysisFiltersScoreGreater, scoreFilterEllipticFiltersScoreGreater, _callback);

    }

    /**
     * Export whitelisted addresses
     * This endpoint exports a list of whitelisted addresses
     * @param format  (optional)
     * @param exchangeAccountId Use exchangeAccountIds instead (optional)
     * @param addressType  (optional)
     * @param query  (optional)
     * @param currency Use blockchain instead (optional)
     * @param scoreProvider Deprecated. Use scoreFilter instead. (optional)
     * @param scoreInBelow Deprecated. Use scoreFilter instead. (optional)
     * @param scoreOutBelow Deprecated. Use scoreFilter instead. (optional)
     * @param scoreExclusive Deprecated. Use scoreFilter instead. (optional)
     * @param exchangeAccountIds  (optional)
     * @param coinfirmScoreGreater Deprecated. Use scoreFilter instead. (optional)
     * @param tags  (optional)
     * @param chainalysisScoreGreater Deprecated. Use scoreFilter instead. (optional)
     * @param blockchain Filter on the blockchain of the WLA (optional)
     * @param addresses Filter on the specific WLAs to export (optional)
     * @param network  (optional)
     * @param scoreFilterScoreProvider Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: &#39;scorechain&#39;, &#39;coinfirm&#39;, &#39;chainalysis&#39;, &#39;elliptic&#39; (optional)
     * @param scoreFilterScorechainFiltersScoreInBelow Filter addresses under a Scorechain incoming score threshold. (optional)
     * @param scoreFilterScorechainFiltersScoreOutBelow Filter addresses under a Scorechain outgoing score threshold. (optional)
     * @param scoreFilterScorechainFiltersScoreExclusive By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow). (optional)
     * @param scoreFilterCoinfirmFiltersScoreGreater Filter addresses with a Coinfirm C-score above threshold. (optional)
     * @param scoreFilterChainalysisFiltersScoreGreater Filter addresses with a Chainalysis risk score above threshold. (optional)
     * @param scoreFilterEllipticFiltersScoreGreater Filter addresses with an Elliptic risk score above threshold. (optional)
     * @return TgvalidatordExportWhitelistedAddressesReply
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public TgvalidatordExportWhitelistedAddressesReply whitelistServiceExportWhitelistedAddresses(String format, String exchangeAccountId, String addressType, String query, String currency, String scoreProvider, String scoreInBelow, String scoreOutBelow, Boolean scoreExclusive, List<String> exchangeAccountIds, String coinfirmScoreGreater, List<String> tags, String chainalysisScoreGreater, String blockchain, List<String> addresses, String network, String scoreFilterScoreProvider, String scoreFilterScorechainFiltersScoreInBelow, String scoreFilterScorechainFiltersScoreOutBelow, Boolean scoreFilterScorechainFiltersScoreExclusive, String scoreFilterCoinfirmFiltersScoreGreater, String scoreFilterChainalysisFiltersScoreGreater, String scoreFilterEllipticFiltersScoreGreater) throws ApiException {
        ApiResponse<TgvalidatordExportWhitelistedAddressesReply> localVarResp = whitelistServiceExportWhitelistedAddressesWithHttpInfo(format, exchangeAccountId, addressType, query, currency, scoreProvider, scoreInBelow, scoreOutBelow, scoreExclusive, exchangeAccountIds, coinfirmScoreGreater, tags, chainalysisScoreGreater, blockchain, addresses, network, scoreFilterScoreProvider, scoreFilterScorechainFiltersScoreInBelow, scoreFilterScorechainFiltersScoreOutBelow, scoreFilterScorechainFiltersScoreExclusive, scoreFilterCoinfirmFiltersScoreGreater, scoreFilterChainalysisFiltersScoreGreater, scoreFilterEllipticFiltersScoreGreater);
        return localVarResp.getData();
    }

    /**
     * Export whitelisted addresses
     * This endpoint exports a list of whitelisted addresses
     * @param format  (optional)
     * @param exchangeAccountId Use exchangeAccountIds instead (optional)
     * @param addressType  (optional)
     * @param query  (optional)
     * @param currency Use blockchain instead (optional)
     * @param scoreProvider Deprecated. Use scoreFilter instead. (optional)
     * @param scoreInBelow Deprecated. Use scoreFilter instead. (optional)
     * @param scoreOutBelow Deprecated. Use scoreFilter instead. (optional)
     * @param scoreExclusive Deprecated. Use scoreFilter instead. (optional)
     * @param exchangeAccountIds  (optional)
     * @param coinfirmScoreGreater Deprecated. Use scoreFilter instead. (optional)
     * @param tags  (optional)
     * @param chainalysisScoreGreater Deprecated. Use scoreFilter instead. (optional)
     * @param blockchain Filter on the blockchain of the WLA (optional)
     * @param addresses Filter on the specific WLAs to export (optional)
     * @param network  (optional)
     * @param scoreFilterScoreProvider Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: &#39;scorechain&#39;, &#39;coinfirm&#39;, &#39;chainalysis&#39;, &#39;elliptic&#39; (optional)
     * @param scoreFilterScorechainFiltersScoreInBelow Filter addresses under a Scorechain incoming score threshold. (optional)
     * @param scoreFilterScorechainFiltersScoreOutBelow Filter addresses under a Scorechain outgoing score threshold. (optional)
     * @param scoreFilterScorechainFiltersScoreExclusive By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow). (optional)
     * @param scoreFilterCoinfirmFiltersScoreGreater Filter addresses with a Coinfirm C-score above threshold. (optional)
     * @param scoreFilterChainalysisFiltersScoreGreater Filter addresses with a Chainalysis risk score above threshold. (optional)
     * @param scoreFilterEllipticFiltersScoreGreater Filter addresses with an Elliptic risk score above threshold. (optional)
     * @return ApiResponse&lt;TgvalidatordExportWhitelistedAddressesReply&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TgvalidatordExportWhitelistedAddressesReply> whitelistServiceExportWhitelistedAddressesWithHttpInfo(String format, String exchangeAccountId, String addressType, String query, String currency, String scoreProvider, String scoreInBelow, String scoreOutBelow, Boolean scoreExclusive, List<String> exchangeAccountIds, String coinfirmScoreGreater, List<String> tags, String chainalysisScoreGreater, String blockchain, List<String> addresses, String network, String scoreFilterScoreProvider, String scoreFilterScorechainFiltersScoreInBelow, String scoreFilterScorechainFiltersScoreOutBelow, Boolean scoreFilterScorechainFiltersScoreExclusive, String scoreFilterCoinfirmFiltersScoreGreater, String scoreFilterChainalysisFiltersScoreGreater, String scoreFilterEllipticFiltersScoreGreater) throws ApiException {
        okhttp3.Call localVarCall = whitelistServiceExportWhitelistedAddressesValidateBeforeCall(format, exchangeAccountId, addressType, query, currency, scoreProvider, scoreInBelow, scoreOutBelow, scoreExclusive, exchangeAccountIds, coinfirmScoreGreater, tags, chainalysisScoreGreater, blockchain, addresses, network, scoreFilterScoreProvider, scoreFilterScorechainFiltersScoreInBelow, scoreFilterScorechainFiltersScoreOutBelow, scoreFilterScorechainFiltersScoreExclusive, scoreFilterCoinfirmFiltersScoreGreater, scoreFilterChainalysisFiltersScoreGreater, scoreFilterEllipticFiltersScoreGreater, null);
        Type localVarReturnType = new TypeToken<TgvalidatordExportWhitelistedAddressesReply>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Export whitelisted addresses (asynchronously)
     * This endpoint exports a list of whitelisted addresses
     * @param format  (optional)
     * @param exchangeAccountId Use exchangeAccountIds instead (optional)
     * @param addressType  (optional)
     * @param query  (optional)
     * @param currency Use blockchain instead (optional)
     * @param scoreProvider Deprecated. Use scoreFilter instead. (optional)
     * @param scoreInBelow Deprecated. Use scoreFilter instead. (optional)
     * @param scoreOutBelow Deprecated. Use scoreFilter instead. (optional)
     * @param scoreExclusive Deprecated. Use scoreFilter instead. (optional)
     * @param exchangeAccountIds  (optional)
     * @param coinfirmScoreGreater Deprecated. Use scoreFilter instead. (optional)
     * @param tags  (optional)
     * @param chainalysisScoreGreater Deprecated. Use scoreFilter instead. (optional)
     * @param blockchain Filter on the blockchain of the WLA (optional)
     * @param addresses Filter on the specific WLAs to export (optional)
     * @param network  (optional)
     * @param scoreFilterScoreProvider Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: &#39;scorechain&#39;, &#39;coinfirm&#39;, &#39;chainalysis&#39;, &#39;elliptic&#39; (optional)
     * @param scoreFilterScorechainFiltersScoreInBelow Filter addresses under a Scorechain incoming score threshold. (optional)
     * @param scoreFilterScorechainFiltersScoreOutBelow Filter addresses under a Scorechain outgoing score threshold. (optional)
     * @param scoreFilterScorechainFiltersScoreExclusive By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow). (optional)
     * @param scoreFilterCoinfirmFiltersScoreGreater Filter addresses with a Coinfirm C-score above threshold. (optional)
     * @param scoreFilterChainalysisFiltersScoreGreater Filter addresses with a Chainalysis risk score above threshold. (optional)
     * @param scoreFilterEllipticFiltersScoreGreater Filter addresses with an Elliptic risk score above threshold. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceExportWhitelistedAddressesAsync(String format, String exchangeAccountId, String addressType, String query, String currency, String scoreProvider, String scoreInBelow, String scoreOutBelow, Boolean scoreExclusive, List<String> exchangeAccountIds, String coinfirmScoreGreater, List<String> tags, String chainalysisScoreGreater, String blockchain, List<String> addresses, String network, String scoreFilterScoreProvider, String scoreFilterScorechainFiltersScoreInBelow, String scoreFilterScorechainFiltersScoreOutBelow, Boolean scoreFilterScorechainFiltersScoreExclusive, String scoreFilterCoinfirmFiltersScoreGreater, String scoreFilterChainalysisFiltersScoreGreater, String scoreFilterEllipticFiltersScoreGreater, final ApiCallback<TgvalidatordExportWhitelistedAddressesReply> _callback) throws ApiException {

        okhttp3.Call localVarCall = whitelistServiceExportWhitelistedAddressesValidateBeforeCall(format, exchangeAccountId, addressType, query, currency, scoreProvider, scoreInBelow, scoreOutBelow, scoreExclusive, exchangeAccountIds, coinfirmScoreGreater, tags, chainalysisScoreGreater, blockchain, addresses, network, scoreFilterScoreProvider, scoreFilterScorechainFiltersScoreInBelow, scoreFilterScorechainFiltersScoreOutBelow, scoreFilterScorechainFiltersScoreExclusive, scoreFilterCoinfirmFiltersScoreGreater, scoreFilterChainalysisFiltersScoreGreater, scoreFilterEllipticFiltersScoreGreater, _callback);
        Type localVarReturnType = new TypeToken<TgvalidatordExportWhitelistedAddressesReply>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for whitelistServiceGetWhitelistedAddress
     * @param id  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceGetWhitelistedAddressCall(String id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/rest/v1/whitelists/addresses/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyTPV1" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call whitelistServiceGetWhitelistedAddressValidateBeforeCall(String id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling whitelistServiceGetWhitelistedAddress(Async)");
        }

        return whitelistServiceGetWhitelistedAddressCall(id, _callback);

    }

    /**
     * Get a whitelisted address
     * This endpoint returns a whitelisted address
     * @param id  (required)
     * @return TgvalidatordGetSignedWhitelistedAddressEnvelopeReply
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public TgvalidatordGetSignedWhitelistedAddressEnvelopeReply whitelistServiceGetWhitelistedAddress(String id) throws ApiException {
        ApiResponse<TgvalidatordGetSignedWhitelistedAddressEnvelopeReply> localVarResp = whitelistServiceGetWhitelistedAddressWithHttpInfo(id);
        return localVarResp.getData();
    }

    /**
     * Get a whitelisted address
     * This endpoint returns a whitelisted address
     * @param id  (required)
     * @return ApiResponse&lt;TgvalidatordGetSignedWhitelistedAddressEnvelopeReply&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TgvalidatordGetSignedWhitelistedAddressEnvelopeReply> whitelistServiceGetWhitelistedAddressWithHttpInfo(String id) throws ApiException {
        okhttp3.Call localVarCall = whitelistServiceGetWhitelistedAddressValidateBeforeCall(id, null);
        Type localVarReturnType = new TypeToken<TgvalidatordGetSignedWhitelistedAddressEnvelopeReply>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a whitelisted address (asynchronously)
     * This endpoint returns a whitelisted address
     * @param id  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceGetWhitelistedAddressAsync(String id, final ApiCallback<TgvalidatordGetSignedWhitelistedAddressEnvelopeReply> _callback) throws ApiException {

        okhttp3.Call localVarCall = whitelistServiceGetWhitelistedAddressValidateBeforeCall(id, _callback);
        Type localVarReturnType = new TypeToken<TgvalidatordGetSignedWhitelistedAddressEnvelopeReply>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for whitelistServiceGetWhitelistedAddressAttribute
     * @param whitelistedAddressId  (required)
     * @param id  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceGetWhitelistedAddressAttributeCall(String whitelistedAddressId, String id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/rest/v1/whitelists/addresses/{whitelistedAddressId}/attributes/{id}"
            .replace("{" + "whitelistedAddressId" + "}", localVarApiClient.escapeString(whitelistedAddressId.toString()))
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyTPV1" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call whitelistServiceGetWhitelistedAddressAttributeValidateBeforeCall(String whitelistedAddressId, String id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'whitelistedAddressId' is set
        if (whitelistedAddressId == null) {
            throw new ApiException("Missing the required parameter 'whitelistedAddressId' when calling whitelistServiceGetWhitelistedAddressAttribute(Async)");
        }

        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling whitelistServiceGetWhitelistedAddressAttribute(Async)");
        }

        return whitelistServiceGetWhitelistedAddressAttributeCall(whitelistedAddressId, id, _callback);

    }

    /**
     * List attributes
     * This endpoint returns a list of attributes of a given whitelisted address
     * @param whitelistedAddressId  (required)
     * @param id  (required)
     * @return TgvalidatordGetWhitelistedAddressAttributeReply
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public TgvalidatordGetWhitelistedAddressAttributeReply whitelistServiceGetWhitelistedAddressAttribute(String whitelistedAddressId, String id) throws ApiException {
        ApiResponse<TgvalidatordGetWhitelistedAddressAttributeReply> localVarResp = whitelistServiceGetWhitelistedAddressAttributeWithHttpInfo(whitelistedAddressId, id);
        return localVarResp.getData();
    }

    /**
     * List attributes
     * This endpoint returns a list of attributes of a given whitelisted address
     * @param whitelistedAddressId  (required)
     * @param id  (required)
     * @return ApiResponse&lt;TgvalidatordGetWhitelistedAddressAttributeReply&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TgvalidatordGetWhitelistedAddressAttributeReply> whitelistServiceGetWhitelistedAddressAttributeWithHttpInfo(String whitelistedAddressId, String id) throws ApiException {
        okhttp3.Call localVarCall = whitelistServiceGetWhitelistedAddressAttributeValidateBeforeCall(whitelistedAddressId, id, null);
        Type localVarReturnType = new TypeToken<TgvalidatordGetWhitelistedAddressAttributeReply>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List attributes (asynchronously)
     * This endpoint returns a list of attributes of a given whitelisted address
     * @param whitelistedAddressId  (required)
     * @param id  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceGetWhitelistedAddressAttributeAsync(String whitelistedAddressId, String id, final ApiCallback<TgvalidatordGetWhitelistedAddressAttributeReply> _callback) throws ApiException {

        okhttp3.Call localVarCall = whitelistServiceGetWhitelistedAddressAttributeValidateBeforeCall(whitelistedAddressId, id, _callback);
        Type localVarReturnType = new TypeToken<TgvalidatordGetWhitelistedAddressAttributeReply>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for whitelistServiceGetWhitelistedAddresses
     * @param limit  (optional)
     * @param offset  (optional)
     * @param exchangeAccountId Use exchangeAccountIds instead (optional)
     * @param addressType  (optional)
     * @param query  (optional)
     * @param currency Use blockchain instead (optional)
     * @param scoreProvider Deprecated. Use scoreFilter instead. (optional)
     * @param scoreInBelow Deprecated. Use scoreFilter instead. (optional)
     * @param scoreOutBelow Deprecated. Use scoreFilter instead. (optional)
     * @param scoreExclusive Deprecated. Use scoreFilter instead. (optional)
     * @param rulesContainerNormalized Normalize rules containers in its own object. (optional)
     * @param exchangeAccountIds  (optional)
     * @param coinfirmScoreGreater Deprecated. Use scoreFilter instead. (optional)
     * @param tagIDs Filter addresses with a &#39;OR&#39; combination of tag IDs (optional)
     * @param chainalysisScoreGreater Deprecated. Use scoreFilter instead. (optional)
     * @param contractType Filter addresses by Contract Type (optional)
     * @param allowedForAddressId Filter addresses allowed to receive funds from this address id (optional)
     * @param allowedForWalletId Filter addresses allowed to receive funds from this wallet id. Will be ignored if allowedForAddressId is filled. (optional)
     * @param blockchain Filter on the blockchain of the WLA (optional)
     * @param includeForApproval  (optional)
     * @param addresses Filter on the specific addresses to return (optional)
     * @param network  (optional)
     * @param ids  (optional)
     * @param tnParticipantID  (optional)
     * @param scoreFilterScoreProvider Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: &#39;scorechain&#39;, &#39;coinfirm&#39;, &#39;chainalysis&#39;, &#39;elliptic&#39; (optional)
     * @param scoreFilterScorechainFiltersScoreInBelow Filter addresses under a Scorechain incoming score threshold. (optional)
     * @param scoreFilterScorechainFiltersScoreOutBelow Filter addresses under a Scorechain outgoing score threshold. (optional)
     * @param scoreFilterScorechainFiltersScoreExclusive By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow). (optional)
     * @param scoreFilterCoinfirmFiltersScoreGreater Filter addresses with a Coinfirm C-score above threshold. (optional)
     * @param scoreFilterChainalysisFiltersScoreGreater Filter addresses with a Chainalysis risk score above threshold. (optional)
     * @param scoreFilterEllipticFiltersScoreGreater Filter addresses with an Elliptic risk score above threshold. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceGetWhitelistedAddressesCall(String limit, String offset, String exchangeAccountId, String addressType, String query, String currency, String scoreProvider, String scoreInBelow, String scoreOutBelow, Boolean scoreExclusive, Boolean rulesContainerNormalized, List<String> exchangeAccountIds, String coinfirmScoreGreater, List<String> tagIDs, String chainalysisScoreGreater, String contractType, String allowedForAddressId, String allowedForWalletId, String blockchain, Boolean includeForApproval, List<String> addresses, String network, List<String> ids, String tnParticipantID, String scoreFilterScoreProvider, String scoreFilterScorechainFiltersScoreInBelow, String scoreFilterScorechainFiltersScoreOutBelow, Boolean scoreFilterScorechainFiltersScoreExclusive, String scoreFilterCoinfirmFiltersScoreGreater, String scoreFilterChainalysisFiltersScoreGreater, String scoreFilterEllipticFiltersScoreGreater, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/rest/v1/whitelists/addresses";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (exchangeAccountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("exchangeAccountId", exchangeAccountId));
        }

        if (addressType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("addressType", addressType));
        }

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        if (currency != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency", currency));
        }

        if (scoreProvider != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreProvider", scoreProvider));
        }

        if (scoreInBelow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreInBelow", scoreInBelow));
        }

        if (scoreOutBelow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreOutBelow", scoreOutBelow));
        }

        if (scoreExclusive != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreExclusive", scoreExclusive));
        }

        if (rulesContainerNormalized != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("rulesContainerNormalized", rulesContainerNormalized));
        }

        if (exchangeAccountIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "exchangeAccountIds", exchangeAccountIds));
        }

        if (coinfirmScoreGreater != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("coinfirmScoreGreater", coinfirmScoreGreater));
        }

        if (tagIDs != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "tagIDs", tagIDs));
        }

        if (chainalysisScoreGreater != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("chainalysisScoreGreater", chainalysisScoreGreater));
        }

        if (contractType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("contractType", contractType));
        }

        if (allowedForAddressId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowedForAddressId", allowedForAddressId));
        }

        if (allowedForWalletId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowedForWalletId", allowedForWalletId));
        }

        if (blockchain != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("blockchain", blockchain));
        }

        if (includeForApproval != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeForApproval", includeForApproval));
        }

        if (addresses != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "addresses", addresses));
        }

        if (network != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("network", network));
        }

        if (ids != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "ids", ids));
        }

        if (tnParticipantID != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tnParticipantID", tnParticipantID));
        }

        if (scoreFilterScoreProvider != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreFilter.scoreProvider", scoreFilterScoreProvider));
        }

        if (scoreFilterScorechainFiltersScoreInBelow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreFilter.scorechainFilters.scoreInBelow", scoreFilterScorechainFiltersScoreInBelow));
        }

        if (scoreFilterScorechainFiltersScoreOutBelow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreFilter.scorechainFilters.scoreOutBelow", scoreFilterScorechainFiltersScoreOutBelow));
        }

        if (scoreFilterScorechainFiltersScoreExclusive != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreFilter.scorechainFilters.scoreExclusive", scoreFilterScorechainFiltersScoreExclusive));
        }

        if (scoreFilterCoinfirmFiltersScoreGreater != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreFilter.coinfirmFilters.scoreGreater", scoreFilterCoinfirmFiltersScoreGreater));
        }

        if (scoreFilterChainalysisFiltersScoreGreater != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreFilter.chainalysisFilters.scoreGreater", scoreFilterChainalysisFiltersScoreGreater));
        }

        if (scoreFilterEllipticFiltersScoreGreater != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scoreFilter.ellipticFilters.scoreGreater", scoreFilterEllipticFiltersScoreGreater));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyTPV1" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call whitelistServiceGetWhitelistedAddressesValidateBeforeCall(String limit, String offset, String exchangeAccountId, String addressType, String query, String currency, String scoreProvider, String scoreInBelow, String scoreOutBelow, Boolean scoreExclusive, Boolean rulesContainerNormalized, List<String> exchangeAccountIds, String coinfirmScoreGreater, List<String> tagIDs, String chainalysisScoreGreater, String contractType, String allowedForAddressId, String allowedForWalletId, String blockchain, Boolean includeForApproval, List<String> addresses, String network, List<String> ids, String tnParticipantID, String scoreFilterScoreProvider, String scoreFilterScorechainFiltersScoreInBelow, String scoreFilterScorechainFiltersScoreOutBelow, Boolean scoreFilterScorechainFiltersScoreExclusive, String scoreFilterCoinfirmFiltersScoreGreater, String scoreFilterChainalysisFiltersScoreGreater, String scoreFilterEllipticFiltersScoreGreater, final ApiCallback _callback) throws ApiException {
        return whitelistServiceGetWhitelistedAddressesCall(limit, offset, exchangeAccountId, addressType, query, currency, scoreProvider, scoreInBelow, scoreOutBelow, scoreExclusive, rulesContainerNormalized, exchangeAccountIds, coinfirmScoreGreater, tagIDs, chainalysisScoreGreater, contractType, allowedForAddressId, allowedForWalletId, blockchain, includeForApproval, addresses, network, ids, tnParticipantID, scoreFilterScoreProvider, scoreFilterScorechainFiltersScoreInBelow, scoreFilterScorechainFiltersScoreOutBelow, scoreFilterScorechainFiltersScoreExclusive, scoreFilterCoinfirmFiltersScoreGreater, scoreFilterChainalysisFiltersScoreGreater, scoreFilterEllipticFiltersScoreGreater, _callback);

    }

    /**
     * List whitelisted addresses
     * This endpoint returns a list of whitelisted addresses
     * @param limit  (optional)
     * @param offset  (optional)
     * @param exchangeAccountId Use exchangeAccountIds instead (optional)
     * @param addressType  (optional)
     * @param query  (optional)
     * @param currency Use blockchain instead (optional)
     * @param scoreProvider Deprecated. Use scoreFilter instead. (optional)
     * @param scoreInBelow Deprecated. Use scoreFilter instead. (optional)
     * @param scoreOutBelow Deprecated. Use scoreFilter instead. (optional)
     * @param scoreExclusive Deprecated. Use scoreFilter instead. (optional)
     * @param rulesContainerNormalized Normalize rules containers in its own object. (optional)
     * @param exchangeAccountIds  (optional)
     * @param coinfirmScoreGreater Deprecated. Use scoreFilter instead. (optional)
     * @param tagIDs Filter addresses with a &#39;OR&#39; combination of tag IDs (optional)
     * @param chainalysisScoreGreater Deprecated. Use scoreFilter instead. (optional)
     * @param contractType Filter addresses by Contract Type (optional)
     * @param allowedForAddressId Filter addresses allowed to receive funds from this address id (optional)
     * @param allowedForWalletId Filter addresses allowed to receive funds from this wallet id. Will be ignored if allowedForAddressId is filled. (optional)
     * @param blockchain Filter on the blockchain of the WLA (optional)
     * @param includeForApproval  (optional)
     * @param addresses Filter on the specific addresses to return (optional)
     * @param network  (optional)
     * @param ids  (optional)
     * @param tnParticipantID  (optional)
     * @param scoreFilterScoreProvider Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: &#39;scorechain&#39;, &#39;coinfirm&#39;, &#39;chainalysis&#39;, &#39;elliptic&#39; (optional)
     * @param scoreFilterScorechainFiltersScoreInBelow Filter addresses under a Scorechain incoming score threshold. (optional)
     * @param scoreFilterScorechainFiltersScoreOutBelow Filter addresses under a Scorechain outgoing score threshold. (optional)
     * @param scoreFilterScorechainFiltersScoreExclusive By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow). (optional)
     * @param scoreFilterCoinfirmFiltersScoreGreater Filter addresses with a Coinfirm C-score above threshold. (optional)
     * @param scoreFilterChainalysisFiltersScoreGreater Filter addresses with a Chainalysis risk score above threshold. (optional)
     * @param scoreFilterEllipticFiltersScoreGreater Filter addresses with an Elliptic risk score above threshold. (optional)
     * @return TgvalidatordGetSignedWhitelistedAddressEnvelopesReply
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public TgvalidatordGetSignedWhitelistedAddressEnvelopesReply whitelistServiceGetWhitelistedAddresses(String limit, String offset, String exchangeAccountId, String addressType, String query, String currency, String scoreProvider, String scoreInBelow, String scoreOutBelow, Boolean scoreExclusive, Boolean rulesContainerNormalized, List<String> exchangeAccountIds, String coinfirmScoreGreater, List<String> tagIDs, String chainalysisScoreGreater, String contractType, String allowedForAddressId, String allowedForWalletId, String blockchain, Boolean includeForApproval, List<String> addresses, String network, List<String> ids, String tnParticipantID, String scoreFilterScoreProvider, String scoreFilterScorechainFiltersScoreInBelow, String scoreFilterScorechainFiltersScoreOutBelow, Boolean scoreFilterScorechainFiltersScoreExclusive, String scoreFilterCoinfirmFiltersScoreGreater, String scoreFilterChainalysisFiltersScoreGreater, String scoreFilterEllipticFiltersScoreGreater) throws ApiException {
        ApiResponse<TgvalidatordGetSignedWhitelistedAddressEnvelopesReply> localVarResp = whitelistServiceGetWhitelistedAddressesWithHttpInfo(limit, offset, exchangeAccountId, addressType, query, currency, scoreProvider, scoreInBelow, scoreOutBelow, scoreExclusive, rulesContainerNormalized, exchangeAccountIds, coinfirmScoreGreater, tagIDs, chainalysisScoreGreater, contractType, allowedForAddressId, allowedForWalletId, blockchain, includeForApproval, addresses, network, ids, tnParticipantID, scoreFilterScoreProvider, scoreFilterScorechainFiltersScoreInBelow, scoreFilterScorechainFiltersScoreOutBelow, scoreFilterScorechainFiltersScoreExclusive, scoreFilterCoinfirmFiltersScoreGreater, scoreFilterChainalysisFiltersScoreGreater, scoreFilterEllipticFiltersScoreGreater);
        return localVarResp.getData();
    }

    /**
     * List whitelisted addresses
     * This endpoint returns a list of whitelisted addresses
     * @param limit  (optional)
     * @param offset  (optional)
     * @param exchangeAccountId Use exchangeAccountIds instead (optional)
     * @param addressType  (optional)
     * @param query  (optional)
     * @param currency Use blockchain instead (optional)
     * @param scoreProvider Deprecated. Use scoreFilter instead. (optional)
     * @param scoreInBelow Deprecated. Use scoreFilter instead. (optional)
     * @param scoreOutBelow Deprecated. Use scoreFilter instead. (optional)
     * @param scoreExclusive Deprecated. Use scoreFilter instead. (optional)
     * @param rulesContainerNormalized Normalize rules containers in its own object. (optional)
     * @param exchangeAccountIds  (optional)
     * @param coinfirmScoreGreater Deprecated. Use scoreFilter instead. (optional)
     * @param tagIDs Filter addresses with a &#39;OR&#39; combination of tag IDs (optional)
     * @param chainalysisScoreGreater Deprecated. Use scoreFilter instead. (optional)
     * @param contractType Filter addresses by Contract Type (optional)
     * @param allowedForAddressId Filter addresses allowed to receive funds from this address id (optional)
     * @param allowedForWalletId Filter addresses allowed to receive funds from this wallet id. Will be ignored if allowedForAddressId is filled. (optional)
     * @param blockchain Filter on the blockchain of the WLA (optional)
     * @param includeForApproval  (optional)
     * @param addresses Filter on the specific addresses to return (optional)
     * @param network  (optional)
     * @param ids  (optional)
     * @param tnParticipantID  (optional)
     * @param scoreFilterScoreProvider Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: &#39;scorechain&#39;, &#39;coinfirm&#39;, &#39;chainalysis&#39;, &#39;elliptic&#39; (optional)
     * @param scoreFilterScorechainFiltersScoreInBelow Filter addresses under a Scorechain incoming score threshold. (optional)
     * @param scoreFilterScorechainFiltersScoreOutBelow Filter addresses under a Scorechain outgoing score threshold. (optional)
     * @param scoreFilterScorechainFiltersScoreExclusive By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow). (optional)
     * @param scoreFilterCoinfirmFiltersScoreGreater Filter addresses with a Coinfirm C-score above threshold. (optional)
     * @param scoreFilterChainalysisFiltersScoreGreater Filter addresses with a Chainalysis risk score above threshold. (optional)
     * @param scoreFilterEllipticFiltersScoreGreater Filter addresses with an Elliptic risk score above threshold. (optional)
     * @return ApiResponse&lt;TgvalidatordGetSignedWhitelistedAddressEnvelopesReply&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TgvalidatordGetSignedWhitelistedAddressEnvelopesReply> whitelistServiceGetWhitelistedAddressesWithHttpInfo(String limit, String offset, String exchangeAccountId, String addressType, String query, String currency, String scoreProvider, String scoreInBelow, String scoreOutBelow, Boolean scoreExclusive, Boolean rulesContainerNormalized, List<String> exchangeAccountIds, String coinfirmScoreGreater, List<String> tagIDs, String chainalysisScoreGreater, String contractType, String allowedForAddressId, String allowedForWalletId, String blockchain, Boolean includeForApproval, List<String> addresses, String network, List<String> ids, String tnParticipantID, String scoreFilterScoreProvider, String scoreFilterScorechainFiltersScoreInBelow, String scoreFilterScorechainFiltersScoreOutBelow, Boolean scoreFilterScorechainFiltersScoreExclusive, String scoreFilterCoinfirmFiltersScoreGreater, String scoreFilterChainalysisFiltersScoreGreater, String scoreFilterEllipticFiltersScoreGreater) throws ApiException {
        okhttp3.Call localVarCall = whitelistServiceGetWhitelistedAddressesValidateBeforeCall(limit, offset, exchangeAccountId, addressType, query, currency, scoreProvider, scoreInBelow, scoreOutBelow, scoreExclusive, rulesContainerNormalized, exchangeAccountIds, coinfirmScoreGreater, tagIDs, chainalysisScoreGreater, contractType, allowedForAddressId, allowedForWalletId, blockchain, includeForApproval, addresses, network, ids, tnParticipantID, scoreFilterScoreProvider, scoreFilterScorechainFiltersScoreInBelow, scoreFilterScorechainFiltersScoreOutBelow, scoreFilterScorechainFiltersScoreExclusive, scoreFilterCoinfirmFiltersScoreGreater, scoreFilterChainalysisFiltersScoreGreater, scoreFilterEllipticFiltersScoreGreater, null);
        Type localVarReturnType = new TypeToken<TgvalidatordGetSignedWhitelistedAddressEnvelopesReply>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List whitelisted addresses (asynchronously)
     * This endpoint returns a list of whitelisted addresses
     * @param limit  (optional)
     * @param offset  (optional)
     * @param exchangeAccountId Use exchangeAccountIds instead (optional)
     * @param addressType  (optional)
     * @param query  (optional)
     * @param currency Use blockchain instead (optional)
     * @param scoreProvider Deprecated. Use scoreFilter instead. (optional)
     * @param scoreInBelow Deprecated. Use scoreFilter instead. (optional)
     * @param scoreOutBelow Deprecated. Use scoreFilter instead. (optional)
     * @param scoreExclusive Deprecated. Use scoreFilter instead. (optional)
     * @param rulesContainerNormalized Normalize rules containers in its own object. (optional)
     * @param exchangeAccountIds  (optional)
     * @param coinfirmScoreGreater Deprecated. Use scoreFilter instead. (optional)
     * @param tagIDs Filter addresses with a &#39;OR&#39; combination of tag IDs (optional)
     * @param chainalysisScoreGreater Deprecated. Use scoreFilter instead. (optional)
     * @param contractType Filter addresses by Contract Type (optional)
     * @param allowedForAddressId Filter addresses allowed to receive funds from this address id (optional)
     * @param allowedForWalletId Filter addresses allowed to receive funds from this wallet id. Will be ignored if allowedForAddressId is filled. (optional)
     * @param blockchain Filter on the blockchain of the WLA (optional)
     * @param includeForApproval  (optional)
     * @param addresses Filter on the specific addresses to return (optional)
     * @param network  (optional)
     * @param ids  (optional)
     * @param tnParticipantID  (optional)
     * @param scoreFilterScoreProvider Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: &#39;scorechain&#39;, &#39;coinfirm&#39;, &#39;chainalysis&#39;, &#39;elliptic&#39; (optional)
     * @param scoreFilterScorechainFiltersScoreInBelow Filter addresses under a Scorechain incoming score threshold. (optional)
     * @param scoreFilterScorechainFiltersScoreOutBelow Filter addresses under a Scorechain outgoing score threshold. (optional)
     * @param scoreFilterScorechainFiltersScoreExclusive By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow). (optional)
     * @param scoreFilterCoinfirmFiltersScoreGreater Filter addresses with a Coinfirm C-score above threshold. (optional)
     * @param scoreFilterChainalysisFiltersScoreGreater Filter addresses with a Chainalysis risk score above threshold. (optional)
     * @param scoreFilterEllipticFiltersScoreGreater Filter addresses with an Elliptic risk score above threshold. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceGetWhitelistedAddressesAsync(String limit, String offset, String exchangeAccountId, String addressType, String query, String currency, String scoreProvider, String scoreInBelow, String scoreOutBelow, Boolean scoreExclusive, Boolean rulesContainerNormalized, List<String> exchangeAccountIds, String coinfirmScoreGreater, List<String> tagIDs, String chainalysisScoreGreater, String contractType, String allowedForAddressId, String allowedForWalletId, String blockchain, Boolean includeForApproval, List<String> addresses, String network, List<String> ids, String tnParticipantID, String scoreFilterScoreProvider, String scoreFilterScorechainFiltersScoreInBelow, String scoreFilterScorechainFiltersScoreOutBelow, Boolean scoreFilterScorechainFiltersScoreExclusive, String scoreFilterCoinfirmFiltersScoreGreater, String scoreFilterChainalysisFiltersScoreGreater, String scoreFilterEllipticFiltersScoreGreater, final ApiCallback<TgvalidatordGetSignedWhitelistedAddressEnvelopesReply> _callback) throws ApiException {

        okhttp3.Call localVarCall = whitelistServiceGetWhitelistedAddressesValidateBeforeCall(limit, offset, exchangeAccountId, addressType, query, currency, scoreProvider, scoreInBelow, scoreOutBelow, scoreExclusive, rulesContainerNormalized, exchangeAccountIds, coinfirmScoreGreater, tagIDs, chainalysisScoreGreater, contractType, allowedForAddressId, allowedForWalletId, blockchain, includeForApproval, addresses, network, ids, tnParticipantID, scoreFilterScoreProvider, scoreFilterScorechainFiltersScoreInBelow, scoreFilterScorechainFiltersScoreOutBelow, scoreFilterScorechainFiltersScoreExclusive, scoreFilterCoinfirmFiltersScoreGreater, scoreFilterChainalysisFiltersScoreGreater, scoreFilterEllipticFiltersScoreGreater, _callback);
        Type localVarReturnType = new TypeToken<TgvalidatordGetSignedWhitelistedAddressEnvelopesReply>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for whitelistServiceGetWhitelistedAddressesForApproval
     * @param limit  (optional)
     * @param offset  (optional)
     * @param ids  (optional)
     * @param blockchain  (optional)
     * @param addressType  (optional)
     * @param query  (optional)
     * @param network  (optional)
     * @param includeAlreadySignedByUser Set to true to not exclude the pending approval whitelist addresses already signed by the user. Default: false (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceGetWhitelistedAddressesForApprovalCall(String limit, String offset, List<String> ids, String blockchain, String addressType, String query, String network, Boolean includeAlreadySignedByUser, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/rest/v1/whitelists/addresses/for-approval";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (ids != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "ids", ids));
        }

        if (blockchain != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("blockchain", blockchain));
        }

        if (addressType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("addressType", addressType));
        }

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        if (network != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("network", network));
        }

        if (includeAlreadySignedByUser != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeAlreadySignedByUser", includeAlreadySignedByUser));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyTPV1" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call whitelistServiceGetWhitelistedAddressesForApprovalValidateBeforeCall(String limit, String offset, List<String> ids, String blockchain, String addressType, String query, String network, Boolean includeAlreadySignedByUser, final ApiCallback _callback) throws ApiException {
        return whitelistServiceGetWhitelistedAddressesForApprovalCall(limit, offset, ids, blockchain, addressType, query, network, includeAlreadySignedByUser, _callback);

    }

    /**
     * List whitelisted addresses for approval
     * This endpoint returns a list of whitelisted addresses for approval
     * @param limit  (optional)
     * @param offset  (optional)
     * @param ids  (optional)
     * @param blockchain  (optional)
     * @param addressType  (optional)
     * @param query  (optional)
     * @param network  (optional)
     * @param includeAlreadySignedByUser Set to true to not exclude the pending approval whitelist addresses already signed by the user. Default: false (optional)
     * @return TgvalidatordGetSignedWhitelistedAddressEnvelopesReply
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public TgvalidatordGetSignedWhitelistedAddressEnvelopesReply whitelistServiceGetWhitelistedAddressesForApproval(String limit, String offset, List<String> ids, String blockchain, String addressType, String query, String network, Boolean includeAlreadySignedByUser) throws ApiException {
        ApiResponse<TgvalidatordGetSignedWhitelistedAddressEnvelopesReply> localVarResp = whitelistServiceGetWhitelistedAddressesForApprovalWithHttpInfo(limit, offset, ids, blockchain, addressType, query, network, includeAlreadySignedByUser);
        return localVarResp.getData();
    }

    /**
     * List whitelisted addresses for approval
     * This endpoint returns a list of whitelisted addresses for approval
     * @param limit  (optional)
     * @param offset  (optional)
     * @param ids  (optional)
     * @param blockchain  (optional)
     * @param addressType  (optional)
     * @param query  (optional)
     * @param network  (optional)
     * @param includeAlreadySignedByUser Set to true to not exclude the pending approval whitelist addresses already signed by the user. Default: false (optional)
     * @return ApiResponse&lt;TgvalidatordGetSignedWhitelistedAddressEnvelopesReply&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TgvalidatordGetSignedWhitelistedAddressEnvelopesReply> whitelistServiceGetWhitelistedAddressesForApprovalWithHttpInfo(String limit, String offset, List<String> ids, String blockchain, String addressType, String query, String network, Boolean includeAlreadySignedByUser) throws ApiException {
        okhttp3.Call localVarCall = whitelistServiceGetWhitelistedAddressesForApprovalValidateBeforeCall(limit, offset, ids, blockchain, addressType, query, network, includeAlreadySignedByUser, null);
        Type localVarReturnType = new TypeToken<TgvalidatordGetSignedWhitelistedAddressEnvelopesReply>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List whitelisted addresses for approval (asynchronously)
     * This endpoint returns a list of whitelisted addresses for approval
     * @param limit  (optional)
     * @param offset  (optional)
     * @param ids  (optional)
     * @param blockchain  (optional)
     * @param addressType  (optional)
     * @param query  (optional)
     * @param network  (optional)
     * @param includeAlreadySignedByUser Set to true to not exclude the pending approval whitelist addresses already signed by the user. Default: false (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceGetWhitelistedAddressesForApprovalAsync(String limit, String offset, List<String> ids, String blockchain, String addressType, String query, String network, Boolean includeAlreadySignedByUser, final ApiCallback<TgvalidatordGetSignedWhitelistedAddressEnvelopesReply> _callback) throws ApiException {

        okhttp3.Call localVarCall = whitelistServiceGetWhitelistedAddressesForApprovalValidateBeforeCall(limit, offset, ids, blockchain, addressType, query, network, includeAlreadySignedByUser, _callback);
        Type localVarReturnType = new TypeToken<TgvalidatordGetSignedWhitelistedAddressEnvelopesReply>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for whitelistServiceRejectWhitelistedAddress
     * @param body  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceRejectWhitelistedAddressCall(TgvalidatordRejectWhitelistedAddressRequest body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/rest/v1/whitelists/addresses/reject";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyTPV1" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call whitelistServiceRejectWhitelistedAddressValidateBeforeCall(TgvalidatordRejectWhitelistedAddressRequest body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling whitelistServiceRejectWhitelistedAddress(Async)");
        }

        return whitelistServiceRejectWhitelistedAddressCall(body, _callback);

    }

    /**
     * Reject a whitelisted address
     * This endpoint rejects a whitelisted address.  Required role: **WhitelistedAddressApprover**.
     * @param body  (required)
     * @return Object
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public Object whitelistServiceRejectWhitelistedAddress(TgvalidatordRejectWhitelistedAddressRequest body) throws ApiException {
        ApiResponse<Object> localVarResp = whitelistServiceRejectWhitelistedAddressWithHttpInfo(body);
        return localVarResp.getData();
    }

    /**
     * Reject a whitelisted address
     * This endpoint rejects a whitelisted address.  Required role: **WhitelistedAddressApprover**.
     * @param body  (required)
     * @return ApiResponse&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Object> whitelistServiceRejectWhitelistedAddressWithHttpInfo(TgvalidatordRejectWhitelistedAddressRequest body) throws ApiException {
        okhttp3.Call localVarCall = whitelistServiceRejectWhitelistedAddressValidateBeforeCall(body, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Reject a whitelisted address (asynchronously)
     * This endpoint rejects a whitelisted address.  Required role: **WhitelistedAddressApprover**.
     * @param body  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request: indicates that the server cannot or will not process the request due to something that is perceived to be a client error (for example, malformed request syntax, invalid request message framing, or deceptive request routing) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized: indicates that the client request has not been completed because it lacks valid authentication credentials for the requested resource </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden: indicates that the server understands the request but refuses to authorize it </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found: indicates that the server cannot find the requested resource </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error: indicates that the server encountered an unexpected condition that prevented it from fulfilling the request </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service Unavailable: indicates that the server is not ready to handle the request. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call whitelistServiceRejectWhitelistedAddressAsync(TgvalidatordRejectWhitelistedAddressRequest body, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = whitelistServiceRejectWhitelistedAddressValidateBeforeCall(body, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
